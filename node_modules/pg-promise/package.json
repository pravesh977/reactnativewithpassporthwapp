{
  "_args": [
    [
      {
        "raw": "pg-promise",
        "scope": null,
        "escapedName": "pg-promise",
        "name": "pg-promise",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/Users/praveshshrestha/Desktop/myapps/reactnativepassport"
    ]
  ],
  "_from": "pg-promise@latest",
  "_id": "pg-promise@8.1.1",
  "_inCache": true,
  "_location": "/pg-promise",
  "_nodeVersion": "8.9.4",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/pg-promise_8.1.1_1519820801073_0.6642195131562565"
  },
  "_npmUser": {
    "name": "vitaly.tomilov",
    "email": "vitaly.tomilov@gmail.com"
  },
  "_npmVersion": "5.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "pg-promise",
    "scope": null,
    "escapedName": "pg-promise",
    "name": "pg-promise",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/pg-promise/-/pg-promise-8.1.1.tgz",
  "_shasum": "c0e3757a859c83cdc1025f1d7a8f69575e2f645e",
  "_shrinkwrap": null,
  "_spec": "pg-promise",
  "_where": "/Users/praveshshrestha/Desktop/myapps/reactnativepassport",
  "author": {
    "name": "Vitaly Tomilov",
    "email": "vitaly.tomilov@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/vitaly-t/pg-promise/issues",
    "email": "vitaly.tomilov@gmail.com"
  },
  "dependencies": {
    "manakin": "~0.5.1",
    "pg": "~7.4.1",
    "pg-minify": "~0.5.4",
    "spex": "~2.0.2"
  },
  "description": "Promises interface for PostgreSQL",
  "devDependencies": {
    "@types/node": "~9.4.6",
    "JSONStream": "~1.3.2",
    "bluebird": "~3.5.1",
    "coveralls": "~3.0.0",
    "eslint": "~4.18.1",
    "istanbul": "~0.4.5",
    "jasmine-node": "~1.14.5",
    "jsdoc": "~3.5.5",
    "pg-query-stream": "~1.1.1",
    "typescript": "~2.7.2"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-+iyIcRXFunFB96uoUPAwqADm2KfAE0ur5iRtZjl8/pOM3g0IgOEtarXNiStf1G1ToiFoXhGoLiaUg11s3wINQg==",
    "shasum": "c0e3757a859c83cdc1025f1d7a8f69575e2f645e",
    "tarball": "https://registry.npmjs.org/pg-promise/-/pg-promise-8.1.1.tgz",
    "fileCount": 49,
    "unpackedSize": 421084
  },
  "engines": {
    "node": ">=4.5",
    "npm": ">=2.15"
  },
  "files": [
    "lib",
    "typescript"
  ],
  "gitHead": "dfd901950868c7071aa480e712a46af923430d45",
  "homepage": "https://github.com/vitaly-t/pg-promise",
  "keywords": [
    "pg",
    "promise",
    "postgres"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "maintainers": [
    {
      "name": "vitaly.tomilov",
      "email": "vitaly.tomilov@gmail.com"
    }
  ],
  "name": "pg-promise",
  "optionalDependencies": {},
  "readme": "pg-promise\r\n==========\r\n\r\n[Promises/A+] interface for PostgreSQL.\r\n\r\n[![Build Status](https://travis-ci.org/vitaly-t/pg-promise.svg?branch=master)](https://travis-ci.org/vitaly-t/pg-promise)\r\n[![Coverage Status](https://coveralls.io/repos/vitaly-t/pg-promise/badge.svg?branch=master)](https://coveralls.io/r/vitaly-t/pg-promise?branch=master)\r\n[![Package Quality](http://npm.packagequality.com/shield/pg-promise.svg)](http://packagequality.com/#?package=pg-promise)\r\n[![Join the chat at https://gitter.im/vitaly-t/pg-promise](https://img.shields.io/gitter/room/vitaly-t/pg-promise.svg)](https://gitter.im/vitaly-t/pg-promise?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\n---\r\n\r\n* [About](#about)\r\n* [Support & Sponsorship](#support--sponsorship)\r\n* [Documentation](#documentation)\r\n* [Contributing](#contributing) \r\n* [Usage]\r\n  - [Methods](#methods)\r\n  - [Query Formatting](#query-formatting)\r\n    - [Index Variables]  \r\n    - [Named Parameters]\r\n      - [Nested Named Parameters]\r\n  - [Formatting Filters](#formatting-filters)          \r\n    - [SQL Names]  \r\n      - [Alias Filter]    \r\n    - [Raw Text]  \r\n    - [Open Values]\r\n    - [JSON Filter]\r\n    - [CSV Filter]    \r\n  - [Custom Type Formatting]\r\n    - [Explicit CTF]\r\n    - [Symbolic CTF]    \r\n  - [Query Files](#query-files)    \r\n  - [Tasks]    \r\n  - [Transactions]    \r\n    - [Nested Transactions]    \r\n      - [Limitations]   \r\n    - [Configurable Transactions]\r\n    - [Conditional Transactions]    \r\n  - [Library de-initialization]\r\n* [History](#history)\r\n* [License](#license)\r\n\r\n---\r\n\r\n# About\r\n\r\nBuilt on top of [node-postgres], this library adds the following:\r\n\r\n* Automatic connections\r\n* Automatic transactions\r\n* Powerful query-formatting engine\r\n* Support for ES6 generators and ES7 `async/await`\r\n* Declarative approach to handling query results\r\n* Global events reporting for central handling\r\n* Extensive support for external SQL files\r\n* Support for all promise libraries\r\n\r\n# Support & Sponsorship  \r\n\r\n<a href=\"https://lisk.io\" alt=\"LISK\" style=\"outline : none;\" target=\"_blank\">![lisk](https://user-images.githubusercontent.com/5108906/35188739-863a8e40-fe33-11e7-8ec4-f3fe13f43ca7.jpg)</a>\r\n\r\nIf you like what we do, and would like to see it continue, then please consider donating:\r\n\r\n - <a href='https://www.paypal.me/VitalyTomilov'><img alt='Click here to lend your support to: pg-promise and make a donation at PayPal.com !' src='https://github.com/vitaly-t/pg-promise/raw/master/jsdoc/paypal.png' border='0' ></a>\r\n - Bitcoin: `1yki7MXMkuDw8qqe5icVdh1GJZSQSzKZp`\r\n - Lisk: `17030494873278665829L`\r\n\r\n# Documentation\r\n\r\nChapter [Usage] below explains the basics you need to know, while the [Official Documentation]\r\ngets you started, and provides links to all other resources.\r\n\r\n# Contributing\r\n\r\nPlease read the [Contribution Notes](https://github.com/vitaly-t/pg-promise/blob/master/CONTRIBUTING.md) before opening any new issue or PR.\r\n\r\n# Usage\r\n\r\nOnce you have created a [Database] object, according to the steps in the [Official Documentation],\r\nyou get access to the methods documented below. \r\n\r\n## Methods \r\n\r\nAll query methods of the library are based off generic method [query].\r\n\r\nYou should normally use only the derived, result-specific methods for executing queries, all of which are named according\r\nto how many rows of data the query is expected to return, so for each query you should pick the right method:\r\n[none], [one], [oneOrNone], [many], [manyOrNone] = [any]. Do not confuse the method name for the number of rows\r\nto be affected by the query, which is completely irrelevant.\r\n\r\nBy relying on the result-specific methods you protect your code from an unexpected number of data rows,\r\nto be automatically rejected (treated as errors).  \r\n\r\nThere are also a few specific methods that you will often need:\r\n\r\n* [result], [multi], [multiResult] - for verbose and/or multi-query results;\r\n* [map], [each] - for simpler/inline result pre-processing/re-mapping;\r\n* [func], [proc] - to simplify execution of SQL functions/procedures;\r\n* [stream] - to access rows from a query via a read stream;\r\n* [connect], [task], [tx] + [txIf] - for shared connections + automatic transactions, each exposing a connected protocol\r\n  that has additional methods [batch], [page] and [sequence].\r\n\r\nThe protocol is fully customizable / extendable via event [extend].\r\n\r\n**IMPORTANT:**\r\n\r\nThe most important methods to understand from start are [task] and [tx]/[txIf] (see [Tasks] and [Transactions]).\r\nAs documented for method [query], it acquires and releases the connection, which makes it a poor choice for executing\r\nmultiple queries at once. For this reason, [Chaining Queries] is a must-read, to avoid writing the code that misuses connections.\r\n\r\n[Learn by Example] is a beginner's tutorial based on examples.\r\n\r\n## Query Formatting\r\n\r\nThis library comes with embedded query-formatting engine that offers high-performance value escaping,\r\nflexibility and extensibility. It is used by default with all query methods, unless you opt out of it entirely\r\nvia option `pgFormatting` within [Initialization Options].  \r\n\r\nAll formatting methods used internally are available from the [formatting] namespace, so they can also be used\r\ndirectly when needed. The main method there is [format], used by every query method to format the query. \r\n\r\nThe formatting syntax for variables is decided from the type of `values` passed in:\r\n\r\n* [Index Variables] when `values` is an array or a single basic type;\r\n* [Named Parameters] when `values` is an object (other than `Array` or `null`).\r\n\r\n**ATTENTION:** Never use ES6 template strings or manual concatenation to generate queries, as both\r\ncan easily result in broken queries! Only this library's formatting engine knows how to properly escape\r\nvariable values for PostgreSQL.\r\n\r\n### Index Variables\r\n\r\nThe simplest (classic) formatting uses `$1, $2, ...` syntax to inject values into the query string,\r\nbased on their index (from `$1` to `$100000`) from the array of values: \r\n\r\n```js\r\ndb.any('SELECT * FROM product WHERE price BETWEEN $1 AND $2', [1, 10])\r\n```\r\n\r\nThe formatting engine also supports single-value parametrization for queries that use only variable `$1`: \r\n\r\n```js\r\ndb.any('SELECT * FROM users WHERE name = $1', 'John')\r\n```\r\n\r\nThis however works only for types `number`, `string`, `boolean`, `Date` and `null`, because types like `Array`\r\nand `Object` change the way parameters are interpreted. That's why passing in index variables within an array\r\nis advised as safer, to avoid ambiguities.\r\n\r\n### Named Parameters\r\n\r\nWhen a query method is parameterized with `values` as an object, the formatting engine expects the query to use\r\nthe Named Parameter syntax `$*propName*`, with `*` being any of the following open-close pairs: `{}`, `()`, `<>`, `[]`, `//`.\r\n\r\n```js\r\ndb.any('SELECT * FROM users WHERE name = ${name} AND active = $/active/', {\r\n    name: 'John',\r\n    active: true\r\n});\r\n```\r\n\r\nValid variable names are limited to the syntax of open-name JavaScript variables. \r\n\r\nKeep in mind that while property values `null` and `undefined` are both formatted as `null`,\r\nan error is thrown when the property does not exist.\r\n\r\n**`this` reference**\r\n\r\nProperty `this` refers to the formatting object itself, to be inserted as a JSON-formatted string.\r\n\r\n```js\r\ndb.none('INSERT INTO documents(id, doc) VALUES(${id}, ${this})', {\r\n    id: 123,\r\n    body: 'some text'    \r\n})\r\n//=> INSERT INTO documents(id, doc) VALUES(123, '{\"id\":123,\"body\":\"some text\"}')\r\n```    \r\n\r\n#### Nested Named Parameters\r\n\r\n[Named Parameters] support property name nesting of any depth.\r\n\r\n<details>\r\n<summary><b>Example</b></summary>\r\n\r\n```js\r\nconst obj = {\r\n    one: {\r\n        two: {\r\n            three: {\r\n                value1: 123,\r\n                value2: a => {\r\n                    // a = obj.one.two.three\r\n                    return 'hello';\r\n                },\r\n                value3: function(a) {\r\n                    // a = this = obj.one.two.three\r\n                    return 'world';\r\n                },\r\n                value4: {\r\n                    toPostgres: a => {\r\n                        // Custom Type Formatting\r\n                        // a = obj.one.two.three.value4\r\n                        return a.text;\r\n                    },\r\n                    text: 'custom'\r\n                }                \r\n            }\r\n        }\r\n    }\r\n};\r\ndb.one('SELECT ${one.two.three.value1}', obj); //=> SELECT 123\r\ndb.one('SELECT ${one.two.three.value2}', obj); //=> SELECT 'hello'\r\ndb.one('SELECT ${one.two.three.value3}', obj); //=> SELECT 'world'\r\ndb.one('SELECT ${one.two.three.value4}', obj); //=> SELECT 'custom'\r\n```\r\n</details>\r\n<br/>\r\n\r\nThe last name in the resolution can be anything, including:\r\n\r\n* the actual value (basic JavaScript type)\r\n* a function that returns:\r\n  - the actual value\r\n  - another function\r\n  - a [Custom Type Formatting] object\r\n* a [Custom Type Formatting] object that returns:\r\n  - the actual value\r\n  - another [Custom Type Formatting] object\r\n  - a function\r\n\r\ni.e. the resolution chain is infinitely flexible, and supports recursion without limits.\r\n\r\nPlease note, however, that nested parameters are not supported within the [helpers] namespace.\r\n\r\n## Formatting Filters\r\n\r\nBy default, all values are formatted according to their JavaScript type. Formatting filters (or modifiers),\r\nchange that, so the value is formatted differently. \r\n\r\nFilters use the same syntax for [Index Variables] and [Named Parameters], following immediately the variable name:\r\n\r\n<details>\r\n<summary><b>With Index Variables</b></summary>\r\n\r\n```js\r\ndb.any('SELECT $1:name FROM $2:name', ['price', 'products'])\r\n//=> SELECT \"price\" FROM \"products\"\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary><b>With Named Parameters</b></summary>\r\n\r\n```js\r\ndb.any('SELECT ${column:name} FROM ${table:name}', {\r\n    column: 'price',\r\n    table: 'products'    \r\n});\r\n//=> SELECT \"price\" FROM \"products\"\r\n```\r\n</details>\r\n<br/>\r\n\r\nThe following filters are supported:\r\n\r\n* `:name` / `~` - [SQL Names]\r\n  - `:alias` - [Alias Filter]\r\n* `:raw` / `^` - [Raw Text]\r\n* `:value` / `#` - [Open Values]\r\n* `:json` - [JSON Filter]\r\n* `:csv` - [CSV Filter]\r\n\r\n### SQL Names\r\n\r\nWhen a variable ends with `:name`, or shorter syntax `~` (tilde), it represents an SQL name or identifier,\r\nto be escaped accordingly, and then wrapped in double quotes:\r\n\r\n<details>\r\n<summary><b>Using ~ filter</b></summary>\r\n\r\n```js\r\ndb.query('INSERT INTO $1~($2~) VALUES(...)', ['Table Name', 'Column Name']);\r\n//=> INSERT INTO \"Table Name\"(\"Column Name\") VALUES(...)\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary><b>Using :name filter</b></summary>\r\n\r\n```js\r\ndb.query('INSERT INTO $1:name($2:name) VALUES(...)', ['Table Name', 'Column Name']);\r\n//=> INSERT INTO \"Table Name\"(\"Column Name\") VALUES(...)\r\n```\r\n</details>\r\n<br/>\r\n\r\nTypically, an SQL name variable is a text string, which must be at least 1 character long.\r\nHowever, `pg-promise` supports a variety of ways in which SQL names can be supplied:\r\n\r\n* A string that contains only `*` (asterisks) is automatically recognized as _all columns_:\r\n\r\n```js\r\ndb.query('SELECT $1:name FROM $2:name', ['*', 'table']);\r\n//=> SELECT * FROM \"table\"\r\n```\r\n\r\n* An array of strings to represent column names:\r\n\r\n```js\r\ndb.query('SELECT ${columns:name} FROM ${table:name}', {\r\n    columns: ['column1', 'column2'],\r\n    table: 'table'\r\n});\r\n//=> SELECT \"column1\",\"column2\" FROM \"table\"\r\n```\r\n\r\n* Any object that's not an array gets its properties enumerated for column names:\r\n\r\n```js\r\nconst obj = {\r\n    one: 1,\r\n    two: 2\r\n};\r\ndb.query('SELECT $1:name FROM $2:name', [obj, 'table']);\r\n//=> SELECT \"one\",\"two\" FROM \"table\"\r\n```\r\n\r\nIn addition, the syntax supports `this` to enumerate column names from the formatting object:\r\n \r\n```js\r\nconst obj = {\r\n    one: 1,\r\n    two: 2\r\n};\r\ndb.query('INSERT INTO table(${this:name}) VALUES(${this:csv})', obj);\r\n//=> INSERT INTO table(\"one\",\"two\") VALUES(1, 2)\r\n```\r\n\r\nRelying on this type of formatting for sql names and identifiers, along with regular variable formatting\r\nprotects your application from [SQL injection].\r\n\r\nMethod [as.name] implements the formatting.\r\n\r\n#### Alias Filter\r\n\r\nAn alias is a lighter/simpler version of [SQL Names], which only supports a text string, and is used via the `:alias` filter.\r\n\r\nFor example, it will skip adding surrounding double quotes when the name is a same-case single word:\r\n\r\n```js\r\ndb.any('SELECT full_name as $1:alias FROM $2:name', ['name', 'table']);\r\n//=> SELECT full_name as name FROM \"table\"\r\n```\r\n\r\nFor more details see method [as.alias] that implements the formatting.\r\n\r\n### Raw Text\r\n\r\nWhen a variable ends with `:raw`, or shorter syntax `^`, the value is to be injected as raw text, without escaping.\r\n\r\nSuch variables cannot be `null` or `undefined`, because of the ambiguous meaning in this case, and those values\r\nwill throw error `Values null/undefined cannot be used as raw text.`\r\n\r\n```js\r\nconst where = pgp.as.format('WHERE price BETWEEN $1 AND $2', [5, 10]); // pre-format WHERE condition\r\ndb.any('SELECT * FROM products $1:raw', where);\r\n//=> SELECT * FROM products WHERE price BETWEEN 5 AND 10\r\n```\r\n\r\nSpecial syntax `this:raw` / `this^` is supported, to inject the formatting object as raw JSON string.\r\n\r\n### Open Values\r\n\r\nWhen a variable ends with `:value`, or shorter syntax `#`, it is escaped as usual, except when its type is a string,\r\nthe trailing quotes are not added.\r\n\r\nOpen values are primarily to be able to compose complete `LIKE`/`ILIKE` dynamic statements in external SQL files,\r\nwithout having to generate them in the code.\r\n\r\ni.e. you can either generate a filter like this in your code:\r\n\r\n```js\r\nconst name = 'John';\r\nconst filter = '%' + name + '%';\r\n```\r\n\r\nand then pass it in as a regular string variable, or you can pass in only `name`, and have your query use the\r\nopen-value syntax to add the extra search logic:\r\n\r\n```sql\r\nSELECT * FROM table WHERE name LIKE '%$1:value%')\r\n```\r\n\r\nMethod [as.value] implements the formatting.\r\n\r\n### JSON Filter\r\n\r\nWhen a variable ends with `:json`, explicit JSON formatting is applied to the value.\r\n\r\nBy default, any object that's not `Date`, `Array`, `null` or Custom-Type (see [Custom Type Formatting]),\r\nis automatically formatted as JSON.\r\n\r\nMethod [as.json] implements the formatting.\r\n\r\n### CSV Filter\r\n\r\nWhen a variable ends with `:csv` or `:list`, it is formatted as a list of Comma-Separated Values, with each\r\nvalue formatted according to its JavaScript type.\r\n\r\nTypically, you would use this for a value that's an array, though it works for single values also. See the examples below.\r\n\r\n<details>\r\n<summary><b>Using :csv filter</b></summary>\r\n\r\n```js\r\nconst ids = [1, 2, 3];\r\ndb.any('SELECT * FROM table WHERE id IN ($1:csv)', [ids])\r\n//=> SELECT * FROM table WHERE id IN (1,2,3)\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary><b>Using :list filter</b></summary>\r\n\r\n```js\r\nconst ids = [1, 2, 3];\r\ndb.any('SELECT * FROM table WHERE id IN ($1:list)', [ids])\r\n//=> SELECT * FROM table WHERE id IN (1,2,3)\r\n```\r\n</details>\r\n<br/>\r\n\r\nUsing automatic property enumeration:\r\n\r\n<details>\r\n<summary><b>Enumeration with :csv filter</b></summary> \r\n\r\n```js\r\nconst obj = {first: 123, second: 'text'};\r\n\r\ndb.none('INSERT INTO table($1:name) VALUES($1:csv)', [obj])\r\n//=> INSERT INTO table(\"first\",\"second\") VALUES(123,'text')\r\n\r\ndb.none('INSERT INTO table(${this:name}) VALUES(${this:csv})', obj)\r\n//=> INSERT INTO table(\"first\",\"second\") VALUES(123,'text')\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary><b>Enumeration with :list filter</b></summary> \r\n\r\n```js\r\nconst obj = {first: 123, second: 'text'};\r\n\r\ndb.none('INSERT INTO table($1:name) VALUES($1:list)', [obj])\r\n//=> INSERT INTO table(\"first\",\"second\") VALUES(123,'text')\r\n\r\ndb.none('INSERT INTO table(${this:name}) VALUES(${this:list})', obj)\r\n//=> INSERT INTO table(\"first\",\"second\") VALUES(123,'text')\r\n```\r\n</details>\r\n<br/>\r\n\r\nMethod [as.csv] implements the formatting.\r\n\r\n## Custom Type Formatting\r\n\r\nThe library supports dual syntax for _CTF_ (Custom Type Formatting):\r\n\r\n* [Explicit CTF] - extending the object/type directly, for ease of use, while changing its signature;\r\n* [Symbolic CTF] - extending the object/type via [Symbol] properties, without changing its signature.\r\n\r\nThe library always first checks for the [Symbolic CTF], and if no such syntax is used, only then it checks for the [Explicit CTF].\r\n\r\n### Explicit CTF\r\n\r\nAny value/object that implements function `toPostgres` is treated as a custom-formatting type. The function is then called to get the actual value,\r\npassing it the object via `this` context, and plus as a single parameter (in case `toPostgres` is an ES6 arrow function):\r\n\r\n```js\r\nconst obj = {\r\n    toPostgres(self) {\r\n        // self = this = obj\r\n        \r\n        // return a value that needs proper escaping\r\n    }\r\n}\r\n```\r\n\r\nFunction `toPostgres` can return anything, including another object with its own `toPostgres` function, i.e. nested custom types are supported.\r\n\r\nThe value returned from `toPostgres` is escaped according to its JavaScript type, unless the object also contains property `rawType` set\r\nto a truthy value, in which case the returned value is considered pre-formatted, and thus injected directly, as [Raw Text]:\r\n\r\n```js\r\nconst obj = {\r\n    toPostgres(self) {\r\n        // self = this = obj\r\n        \r\n        // return a pre-formatted value that does not need escaping\r\n    },\r\n    rawType: true // use result from toPostgres directly, as Raw Text\r\n}\r\n```\r\n\r\nExample below implements a class that auto-formats `ST_MakePoint` from coordinates:\r\n\r\n```js\r\nclass STPoint {\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.rawType = true; // no escaping, because we return pre-formatted SQL\r\n    }\r\n    \r\n    toPostgres(self) {\r\n        return pgp.as.format('ST_MakePoint($1, $2)', [this.x, this.y]);\r\n    }\r\n}\r\n```\r\n\r\nAnd a classic syntax for such a class is even simpler:\r\n\r\n```js\r\nfunction STPoint(x, y){\r\n    this.rawType = true; // no escaping, because we return pre-formatted SQL\r\n    this.toPostgres = () => pgp.as.format('ST_MakePoint($1, $2)', [x, y]);\r\n}\r\n```\r\n\r\nWith this class you can use `new STPoint(12, 34)` as a formatting value that will be injected correctly.  \r\n\r\nYou can also use _CTF_ to override any standard type:\r\n\r\n```js\r\nDate.prototype.toPostgres = a => a.getTime();\r\n```\r\n\r\n### Symbolic CTF\r\n\r\nThe only difference from [Explicit CTF] is that we set `toPostgres` and `rawType` as ES6 [Symbol] properties,\r\ndefined in the [ctf] namespace: \r\n\r\n```js\r\nconst ctf = pgp.as.ctf; // Global CTF symbols\r\n\r\nconst obj = {\r\n    [ctf.toPostgres](self) {\r\n        // self = this = obj\r\n        \r\n        // return a pre-formatted value that does not need escaping\r\n    },\r\n    [ctf.rawType]: true // use result from toPostgres directly, as Raw Text\r\n};\r\n```\r\n\r\nAs CTF symbols are global, you can also configure objects independently of this library:\r\n\r\n```js\r\nconst ctf = {\r\n    toPostgres: Symbol.for('ctf.toPostgres'),\r\n    rawType: Symbol.for('ctf.rawType')\r\n};\r\n```\r\n\r\nOther than that, it works exactly as the [Explicit CTF], but without changing the object's signature.\r\n\r\nIf you do not know what it means, read the ES6 [Symbol] API and its use for unique property names.\r\nBut in short, [Symbol] properties are not enumerated via `for(name in obj)`, i.e. they are not generally\r\nvisible within JavaScript, only through specific API `Object.getOwnPropertySymbols`.\r\n\r\n## Query Files\r\n  \r\nUse of external SQL files (via [QueryFile]) offers many advantages:\r\n\r\n* Much cleaner JavaScript code, with all SQL kept in external files;\r\n* Much easier to write large and well-formatted SQL, with many comments and whole revisions;\r\n* Changes in external SQL can be automatically re-loaded (option `debug`), without restarting the app;\r\n* Pre-formatting SQL upon loading (option `params`), automating two-step SQL formatting;\r\n* Parsing and minifying SQL (options `minify` + `compress`), for early error detection and compact queries.\r\n\r\n<details>\r\n<summary><b>Example</b></summary>\r\n\r\n```js\r\nconst path = require('path');\r\n\r\n// Helper for linking to external query files:\r\nfunction sql(file) {\r\n    const fullPath = path.join(__dirname, file);\r\n    return new pgp.QueryFile(fullPath, {minify: true});\r\n}\r\n\r\n// Create a QueryFile globally, once per file:\r\nconst sqlFindUser = sql('./sql/findUser.sql');\r\n\r\ndb.one(sqlFindUser, {id: 123})\r\n    .then(user => {\r\n        console.log(user);\r\n    })\r\n    .catch(error => {\r\n        if (error instanceof pgp.errors.QueryFileError) {\r\n            // => the error is related to our QueryFile\r\n        }\r\n    });\r\n```\r\n\r\nFile `findUser.sql`:\r\n\r\n```sql\r\n/*\r\n    multi-line comments are supported\r\n*/\r\nSELECT name, dob -- single-line comments are supported\r\nFROM Users\r\nWHERE id = ${id}\r\n```\r\n</details>\r\n<br/>\r\n\r\nEvery query method of the library can accept type [QueryFile] as its `query` parameter.\r\nThe type never throws any error, leaving it for query methods to gracefully reject with [QueryFileError].\r\n\r\nUse of [Named Parameters] within external SQL files is recommended over the [Index Variables], because it makes the SQL\r\nmuch easier to read and understand, and because it also allows [Nested Named Parameters], so variables in a large\r\nand complex SQL file can be grouped in namespaces for even easier visual separation.\r\n\r\n## Tasks\r\n\r\nA [task] represents a shared connection for executing multiple queries:\r\n\r\n```js\r\ndb.task(t => {\r\n    // execute a chain of queries against the task context, and return the result:\r\n    return t.one('SELECT count(*) FROM events WHERE id = $1', 123, a => +a.count)\r\n        .then(count => {\r\n            if(count > 0) {\r\n                return t.any('SELECT * FROM log WHERE event_id = $1', 123)\r\n                    .then(logs => {\r\n                        return {count, logs};\r\n                    })\r\n            }\r\n            return {count};\r\n        });    \r\n})\r\n    .then(data => {\r\n        // success, data = either {count} or {count, logs}\r\n    })\r\n    .catch(error => {\r\n        // failed    \r\n    });\r\n```\r\n\r\nTasks provide a shared connection context for its callback function, to be released when finished, and\r\nthey must be used whenever executing more than one query at a time. See also [Chaining Queries] to understand\r\nthe importance of using tasks.\r\n\r\nYou can optionally tag tasks (see [Tags]), and use either ES6 generators or ES7 async syntax:\r\n\r\n<details>\r\n  <summary><b>With ES6 generator</b></summary>\r\n  \r\n```js\r\ndb.task(function * (t) {\r\n    const count = yield t.one('SELECT count(*) FROM events WHERE id = $1', 123, a => +a.count);\r\n    if(count > 0) {\r\n        const logs = yield t.any('SELECT * FROM log WHERE event_id = $1', 123);\r\n        return {count, logs};\r\n    }\r\n    return {count};\r\n})\r\n    .then(data => {\r\n        // success, data = either {count} or {count, logs}\r\n    })\r\n    .catch(error => {\r\n        // failed    \r\n    });\r\n```\r\n\r\n</details>\r\n\r\n<details>\r\n  <summary><b>With ES6 generator + tag</b></summary>\r\n  \r\n```js\r\ndb.task('get-event-logs', function * (t) {\r\n    const count = yield t.one('SELECT count(*) FROM events WHERE id = $1', 123, a => +a.count);\r\n    if(count > 0) {\r\n        const logs = yield t.any('SELECT * FROM log WHERE event_id = $1', 123);\r\n        return {count, logs};\r\n    }\r\n    return {count};\r\n})\r\n    .then(data => {\r\n        // success, data = either {count} or {count, logs}\r\n    })\r\n    .catch(error => {\r\n        // failed    \r\n    });\r\n```\r\n\r\n</details>\r\n\r\n<details>\r\n  <summary><b>With ES7 async</b></summary>\r\n  \r\n```js\r\ndb.task(async t => {\r\n    const count = await t.one('SELECT count(*) FROM events WHERE id = $1', 123, a => +a.count);\r\n    if(count > 0) {\r\n        const logs = await t.any('SELECT * FROM log WHERE event_id = $1', 123);\r\n        return {count, logs};\r\n    }\r\n    return {count};\r\n})\r\n    .then(data => {\r\n        // success, data = either {count} or {count, logs}\r\n    })\r\n    .catch(error => {\r\n        // failed    \r\n    });\r\n```\r\n\r\n</details>\r\n\r\n<details>\r\n  <summary><b>With ES7 async + tag</b></summary>\r\n  \r\n```js\r\ndb.task('get-event-logs', async t => {\r\n    const count = await t.one('SELECT count(*) FROM events WHERE id = $1', 123, a => +a.count);\r\n    if(count > 0) {\r\n        const logs = await t.any('SELECT * FROM log WHERE event_id = $1', 123);\r\n        return {count, logs};\r\n    }\r\n    return {count};\r\n})\r\n    .then(data => {\r\n        // success, data = either {count} or {count, logs}\r\n    })\r\n    .catch(error => {\r\n        // failed    \r\n    });\r\n```\r\n\r\n</details>\r\n\r\n## Transactions\r\n\r\nTransaction method [tx] is like [task], which also executes `BEGIN` + `COMMIT`/`ROLLBACK`:\r\n\r\n```js\r\ndb.tx(t => {\r\n    // creating a sequence of transaction queries:\r\n    const q1 = t.none('UPDATE users SET active = $1 WHERE id = $2', [true, 123]);\r\n    const q2 = t.one('INSERT INTO audit(entity, id) VALUES($1, $2) RETURNING id', ['users', 123]);\r\n\r\n    // returning a promise that determines a successful transaction:\r\n    return t.batch([q1, q2]); // all of the queries are to be resolved;\r\n})\r\n    .then(data => {\r\n        // success, COMMIT was executed\r\n    })\r\n    .catch(error => {\r\n        // failure, ROLLBACK was executed\r\n    });\r\n```\r\n\r\nIf the callback function returns a rejected promise or throws an error, the method will automatically execute `ROLLBACK` at the end. \r\nIn all other cases the transaction will be automatically closed by `COMMIT`.\r\n\r\nThe same as tasks, transactions support [Tags], ES6 generators and ES7 async:\r\n\r\n<details>\r\n<summary><b>With ES6 generator</b></summary>\r\n\r\n```js\r\ndb.tx(function * (t) {\r\n    yield t.none('UPDATE users SET active = $1 WHERE id = $2', [true, 123]);\r\n    yield t.one('INSERT INTO audit(entity, id) VALUES($1, $2) RETURNING id', ['users', 123]);\r\n})\r\n    .then(data => {\r\n        // success, COMMIT was executed\r\n    })\r\n    .catch(error => {\r\n        // failure, ROLLBACK was executed\r\n    });\r\n```\r\n\r\n</details>\r\n\r\n<details>\r\n<summary><b>With ES6 generator + tag</b></summary>\r\n\r\n```js\r\ndb.tx('update-user', function * (t) {\r\n    yield t.none('UPDATE users SET active = $1 WHERE id = $2', [true, 123]);\r\n    yield t.one('INSERT INTO audit(entity, id) VALUES($1, $2) RETURNING id', ['users', 123]);\r\n})\r\n    .then(data => {\r\n        // success, COMMIT was executed\r\n    })\r\n    .catch(error => {\r\n        // failure, ROLLBACK was executed\r\n    });\r\n```\r\n\r\n</details>\r\n\r\n<details>\r\n<summary><b>With ES7 async</b></summary>\r\n\r\n```js\r\ndb.tx(async t => {\r\n    await t.none('UPDATE users SET active = $1 WHERE id = $2', [true, 123]);\r\n    await t.one('INSERT INTO audit(entity, id) VALUES($1, $2) RETURNING id', ['users', 123]);\r\n})\r\n    .then(data => {\r\n        // success, COMMIT was executed\r\n    })\r\n    .catch(error => {\r\n        // failure, ROLLBACK was executed\r\n    });\r\n```\r\n\r\n</details>\r\n\r\n<details>\r\n<summary><b>With ES7 async + tag</b></summary>\r\n\r\n```js\r\ndb.tx('update-user', async t => {\r\n    await t.none('UPDATE users SET active = $1 WHERE id = $2', [true, 123]);\r\n    await t.one('INSERT INTO audit(entity, id) VALUES($1, $2) RETURNING id', ['users', 123]);\r\n})\r\n    .then(data => {\r\n        // success, COMMIT was executed\r\n    })\r\n    .catch(error => {\r\n        // failure, ROLLBACK was executed\r\n    });\r\n```\r\n\r\n</details>\r\n\r\n### Nested Transactions\r\n\r\nNested transactions automatically share the connection between all levels.\r\nThis library sets no limitation as to the depth (nesting levels) of transactions supported.\r\n\r\n<details>\r\n<summary><b>Example</b></summary>\r\n\r\n```js\r\ndb.tx(t => {\r\n    const queries = [\r\n        t.none('DROP TABLE users;'),\r\n        t.none('CREATE TABLE users(id SERIAL NOT NULL, name TEXT NOT NULL)')\r\n    ];\r\n    for (let i = 1; i <= 100; i++) {\r\n        queries.push(t.none('INSERT INTO users(name) VALUES($1)', 'name-' + i));\r\n    }\r\n    queries.push(\r\n        t.tx(t1 => {\r\n            return t1.tx(t2 => {\r\n                return t2.one('SELECT count(*) FROM users');\r\n            });\r\n        }));\r\n    return t.batch(queries);\r\n})\r\n    .then(data => {\r\n        // success\r\n    })\r\n    .catch(error => {\r\n        // failure\r\n    });\r\n```\r\n</details>\r\n<br/>\r\n\r\nIf you want to avoid automatic occurrence of nested transactions, see [Conditional Transactions].\r\n\r\n#### Limitations\r\n\r\nIt is important to know that PostgreSQL does not support full/atomic nested transactions, it only\r\nsupports [savepoints](http://www.postgresql.org/docs/9.6/static/sql-savepoint.html) inside top-level\r\ntransactions, to allow *partial rollbacks*.\r\n\r\nPostgres uses `BEGIN` with `COMMIT / ROLLBACK` for top-level transactions, and `SAVEPOINT name`\r\nwith `RELEASE / ROLLBACK TO name` for inner save-points.\r\n\r\nThis library automatically executes all such transaction and savepoint commands, with unique\r\nsavepoint names, based on the transaction level.\r\n\r\n### Configurable Transactions\r\n\r\n[TransactionMode] type can extend your `BEGIN` command with transaction configuration:\r\n\r\n```js\r\nconst TransactionMode = pgp.txMode.TransactionMode;\r\nconst isolationLevel = pgp.txMode.isolationLevel;\r\n \r\n// Create a reusable transaction mode (serializable + read-only + deferrable):\r\nconst mode = new TransactionMode({\r\n    tiLevel: isolationLevel.serializable,\r\n    readOnly: true,\r\n    deferrable: true\r\n});\r\n\r\ndb.tx({mode}, t => {\r\n    // do transaction queries here\r\n})\r\n    .then(() => {\r\n        // success;\r\n    })\r\n    .catch(error => {\r\n        // failure    \r\n    });\r\n```\r\n\r\nInstead of the default `BEGIN`, such transaction will open with the following command:\r\n```\r\nBEGIN ISOLATION LEVEL SERIALIZABLE READ ONLY DEFERRABLE\r\n```\r\n\r\n_Transaction Mode_ is set via option `mode`, preceding the the callback function. See methods [tx] and [txIf].\r\n\r\nThis is the most efficient and best-performing way of configuring transactions. In combination with\r\n*Transaction Snapshots* you can make the most out of transactions in terms of performance and concurrency.\r\n\r\n### Conditional Transactions\r\n\r\nMethod [txIf] executes a transaction / [tx] when a specified condition is met, or else it executes a [task]. \r\n\r\nWhen no condition is specified, the default is to start a transaction, if currently not in one, or else it starts a task.\r\nIt is useful when you want to avoid [Nested Transactions] - savepoints.\r\n\r\n<details>\r\n<summary><b>With default condition</b></summary>\r\n \r\n```js\r\ndb.txIf(t => {\r\n    // transaction is started, as the top level doesn't have one\r\n    return t.txIf(t2 => {\r\n        // a task is started, because there is a parent transaction        \r\n    });\r\n})\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary><b>With a custom condition - value</b></summary>\r\n\r\n```js\r\ndb.txIf({cnd: someValue}, t => {\r\n    // if condition is truthy, a transaction is started\r\n    return t.txIf(t2 => {\r\n        // a task is started, if the parent is a transaction\r\n        // a transaction is started, if the parent is a task\r\n    });\r\n})\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary><b>With a custom condition - callback</b></summary>\r\n\r\n```js\r\nconst cnd = c => {\r\n    // c.ctx - task/transaction context (not available on the top level)\r\n    // default condition: return !c.ctx || !c.ctx.inTransaction;\r\n    return someValue;\r\n};\r\n\r\ndb.txIf({cnd}, t => {\r\n    // if condition is truthy, a transaction is started\r\n    return t.txIf(t2 => {\r\n        // a task is started, if the parent is a transaction\r\n        // a transaction is started, if the parent is a task\r\n    });\r\n})\r\n```\r\n</details>\r\n\r\n## Library de-initialization\r\n\r\nThis library manages all database connections via the [connection pool], which internally caches them.\r\n\r\nConnections in the cache expire due to inactivity after [idleTimeoutMillis] number of milliseconds, which you\r\ncan adjust when creating the [Database] object, or override the default via `pgp.pg.defaults.idleTimeoutMillis`\r\nbefore creating the [Database] object. \r\n\r\nWhile there is a single open connection in the pool, the process cannot terminate by itself, only via `process.exit()`. \r\nIf you want the process to finish by itself, without waiting for all connections in the pool to expire, you need\r\nto force the pool to shut down all the connections it holds:\r\n\r\n```js\r\ndb.$pool.end(); // shuts down the connection pool associated with the Database object\r\n``` \r\n\r\nFor example, if you are using the [Bluebird] library, you can chain the last promise in the process like this:\r\n\r\n```js\r\n.finally(db.$pool.end);\r\n``` \r\n\r\n**IMPORTANT:** Note that if your app is an HTTP service, or generally an application that does not feature any exit point,\r\nthen you should not do any de-initialization at all. It is only if your app is a run-through process/utility, then you\r\nmight want to use it, so the process ends without delays.  \r\n\r\nIn applications that either use multiple databases or execute a multi-pool strategy for balanced query loads, you would end up\r\nwith multiple [Database] objects, each with its own connection pool. In this scenario, in order to exit the process normally,\r\nat a particular point, you can call [pgp.end] to shut down all connection pools at once:\r\n\r\n```js\r\npgp.end(); // shuts down all connection pools created in the process\r\n```\r\n\r\nor promise-chained to the last query block in the process:\r\n\r\n```js\r\n.finally(pgp.end);\r\n``` \r\n\r\nOnce you have shut down the pool associated with your [Database] object, you can no longer use the object, and any of its query methods\r\nwill be rejecting with [Error] = `Connection pool of the database object has been destroyed`.\r\n\r\nSee the relevant API: [pgp.end], [Database.$pool]\r\n \r\n# History\r\n\r\nFor the list of all changes see the [CHANGELOG](CHANGELOG.md).\r\n\r\n# License\r\n\r\nCopyright (c) 2018 Vitaly Tomilov\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\r\nto deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\nand/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\nDEALINGS IN THE SOFTWARE.\r\n\r\n<!-- Internal Menu Links -->\r\n\r\n[Usage]:#usage\r\n[Index Variables]:#index-variables  \r\n[Named Parameters]:#named-parameters\r\n[Nested Named Parameters]:#nested-named-parameters\r\n[SQL Names]:#sql-names\r\n[Raw Text]:#raw-text\r\n[Open Values]:#open-values\r\n[Alias Filter]:#alias-filter\r\n[JSON Filter]:#json-filter\r\n[CSV Filter]:#csv-filter\r\n[Custom Type Formatting]:#custom-type-formatting\r\n[Explicit CTF]:#explicit-ctf\r\n[Symbolic CTF]:#symbolic-ctf\r\n[Tasks]:#tasks    \r\n[Transactions]:#transactions\r\n[Nested Transactions]:#nested-transactions    \r\n[Limitations]:#limitations   \r\n[Configurable Transactions]:#configurable-transactions\r\n[Conditional Transactions]:#conditional-transactions    \r\n[Library de-initialization]:#library-de-initialization\r\n\r\n<!-- Database Method Links -->\r\n\r\n[query]:http://vitaly-t.github.io/pg-promise/Database.html#query\r\n[none]:http://vitaly-t.github.io/pg-promise/Database.html#none\r\n[one]:http://vitaly-t.github.io/pg-promise/Database.html#one\r\n[oneOrNone]:http://vitaly-t.github.io/pg-promise/Database.html#oneOrNone\r\n[many]:http://vitaly-t.github.io/pg-promise/Database.html#many\r\n[manyOrNone]:http://vitaly-t.github.io/pg-promise/Database.html#manyOrNone\r\n[any]:http://vitaly-t.github.io/pg-promise/Database.html#any\r\n[result]:http://vitaly-t.github.io/pg-promise/Database.html#result\r\n[multi]:http://vitaly-t.github.io/pg-promise/Database.html#multi\r\n[multiResult]:http://vitaly-t.github.io/pg-promise/Database.html#multiResult\r\n[map]:http://vitaly-t.github.io/pg-promise/Database.html#map\r\n[each]:http://vitaly-t.github.io/pg-promise/Database.html#each\r\n[func]:http://vitaly-t.github.io/pg-promise/Database.html#func\r\n[proc]:http://vitaly-t.github.io/pg-promise/Database.html#proc\r\n[stream]:http://vitaly-t.github.io/pg-promise/Database.html#stream\r\n[connect]:http://vitaly-t.github.io/pg-promise/Database.html#connect\r\n[task]:http://vitaly-t.github.io/pg-promise/Database.html#task\r\n[tx]:http://vitaly-t.github.io/pg-promise/Database.html#tx\r\n[txIf]:http://vitaly-t.github.io/pg-promise/Database.html#txIf\r\n[batch]:http://vitaly-t.github.io/pg-promise/Task.html#batch\r\n[sequence]:http://vitaly-t.github.io/pg-promise/Task.html#sequence\r\n[page]:http://vitaly-t.github.io/pg-promise/Task.html#page\r\n[extend]:http://vitaly-t.github.io/pg-promise/global.html#event:extend\r\n\r\n<!-- API Links -->\r\n\r\n[Official Documentation]:http://vitaly-t.github.io/pg-promise/index.html\r\n[Initialization Options]:http://vitaly-t.github.io/pg-promise/module-pg-promise.html\r\n[helpers]:http://vitaly-t.github.io/pg-promise/helpers.html\r\n[QueryFile]:http://vitaly-t.github.io/pg-promise/QueryFile.html\r\n[QueryFileError]:http://vitaly-t.github.io/pg-promise/QueryFileError.html\r\n[Database]:http://vitaly-t.github.io/pg-promise/Database.html\r\n[Database.$pool]:http://vitaly-t.github.io/pg-promise/Database.html#$pool\r\n[pgp.end]:http://vitaly-t.github.io/pg-promise/module-pg-promise.html#~end\r\n[formatting]:http://vitaly-t.github.io/pg-promise/formatting.html\r\n[ctf]:http://vitaly-t.github.io/pg-promise/formatting.ctf.html\r\n[as.format]:http://vitaly-t.github.io/pg-promise/formatting.html#.format\r\n[format]:http://vitaly-t.github.io/pg-promise/formatting.html#.format\r\n[as.value]:http://vitaly-t.github.io/pg-promise/formatting.html#.value\r\n[as.csv]:http://vitaly-t.github.io/pg-promise/formatting.html#.csv\r\n[as.json]:http://vitaly-t.github.io/pg-promise/formatting.html#.json\r\n[as.name]:http://vitaly-t.github.io/pg-promise/formatting.html#.name\r\n[as.alias]:http://vitaly-t.github.io/pg-promise/formatting.html#.alias\r\n[TransactionMode]:http://vitaly-t.github.io/pg-promise/txMode.TransactionMode.html\r\n\r\n<!-- WiKi Links -->\r\n\r\n[Learn by Example]:https://github.com/vitaly-t/pg-promise/wiki/Learn-by-Example\r\n[Chaining Queries]:https://github.com/vitaly-t/pg-promise/wiki/Chaining-Queries\r\n[Tags]:https://github.com/vitaly-t/pg-promise/wiki/Tags\r\n\r\n<!-- External Links -->\r\n\r\n[node-postgres]:https://github.com/brianc/node-postgres\r\n[Promises/A+]:https://promisesaplus.com/\r\n[Bluebird]:https://github.com/petkaantonov/bluebird\r\n[SQL injection]:https://en.wikipedia.org/wiki/SQL_injection\r\n[Symbol]:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\r\n[idleTimeoutMillis]:https://github.com/brianc/node-postgres/blob/master/lib/defaults.js#L46\r\n[connection pool]:https://github.com/brianc/node-pg-pool\r\n[Error]:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitaly-t/pg-promise.git"
  },
  "scripts": {
    "coverage": "istanbul cover ./node_modules/jasmine-node/bin/jasmine-node test",
    "doc": "jsdoc -c ./jsdoc/jsdoc.js ./jsdoc/README.md -t ./jsdoc/templates/custom",
    "lint": "eslint ./lib ./test/*.js ./test/db",
    "test": "jasmine-node test",
    "test:native": "jasmine-node test --config PG_NATIVE true",
    "travis": "npm run lint && istanbul cover ./node_modules/jasmine-node/bin/jasmine-node test --captureExceptions && cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js && rm -rf ./coverage"
  },
  "typings": "typescript/pg-promise.d.ts",
  "version": "8.1.1"
}
